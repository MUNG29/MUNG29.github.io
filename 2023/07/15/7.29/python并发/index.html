<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf8" />
    <meta name="viewport" content="initial-scale=1.0, width=device-width" />
    <title>
      
        python并发详解 | 东隅's blog
      
    </title>
    <meta name="description" content=""/>
    <meta name="keywords" content=""/>
    
      <link rel="apple-touch-icon"
            sizes="180x180"
            href="/images/jocker.png"/>
    
    
      <link rel="icon"
            type="image/png"
            sizes="32x32"
            href="/images/jocker.png"/>
    
    
      <link rel="icon"
            type="image/png"
            sizes="16x16"
            href="/images/jocker.png"/>
    
    
      <link rel="mask-icon"
            href="/images/jocker.png"
            color=""/>
    
    
    <link rel="stylesheet" type="text/css" href="/css/layout.css"/>
    
    
  <link rel="stylesheet" type="text/css" href="/css/post.css"/>
  

  <meta name="generator" content="Hexo 5.4.0"></head>
  <body>
    <div class="head">
      <div class="nav">
        <a href="/" class="nav-logo">
          <img alt="logo" height="60px" width="60px" src="/images/jocker.png" />
        </a>
        <input id="navBtn" type="checkbox"/>
        <div class="nav-menu">
          
            
              <a class="nav-menu-item" href="/%E5%AE%89%E5%85%A8">安全</a>
            
              <a class="nav-menu-item" href="/%E5%BC%80%E5%8F%91">开发</a>
            
              <a class="nav-menu-item" href="/%E7%94%9F%E6%B4%BB">生活</a>
            
          
        </div>
        <label class="nav-btn" for="navBtn"></label>
      </div>
    </div>
    <div class="body">
      
  <article class="post-content">
    <div class="post-inner">
      <div class="post-content__head">
        <div class="post-title">python并发详解</div>
        <div class="post-info">
          
  
    <a href="/tags/python/" class="post-tag">#python</a>
  


          <span class="post-date">2023-07-15</span>
        </div>
      </div>
      <div id="postBody" class="post-content__body--toc">
        <div id="tocAnchor" class="toc-anchor">
          <ol id="toc" class="post-toc">
            
              <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-text">对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB"><span class="toc-text">关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E6%A0%B7%E9%80%89%E6%8B%A9"><span class="toc-text">怎样选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#python%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-text">python慢的原因</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#threading%E5%BA%93"><span class="toc-text">threading库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AF%B9%E8%B1%A1%EF%BC%9AThread%E7%B1%BB"><span class="toc-text">线程对象：Thread类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E5%AF%B9%E8%B1%A1%EF%BC%9ALock-amp-%E9%80%92%E5%BD%92%E9%94%81%E5%AF%B9%E8%B1%A1%EF%BC%9ARlock%E7%B1%BB"><span class="toc-text">锁对象：Lock &amp; 递归锁对象：Rlock类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%EF%BC%9ACondition%E7%B1%BB"><span class="toc-text">条件变量对象：Condition类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%EF%BC%9AEvent%E7%B1%BB"><span class="toc-text">事件对象：Event类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AF%B9%E8%B1%A1%EF%BC%9Atimer%E7%B1%BB"><span class="toc-text">定时器对象：timer类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#local%E7%B1%BB"><span class="toc-text">local类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">创建多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%88%AC%E8%99%AB"><span class="toc-text">多线程爬虫</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-text">基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85-%E9%98%9F%E5%88%97"><span class="toc-text">生产者-消费者-队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-lock"><span class="toc-text">线程安全 lock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0-threadpoolexecutor"><span class="toc-text">线程池 threadpoolexecutor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%B3%95"><span class="toc-text">用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4"><span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map-%E5%92%8C-submit%E5%AF%B9%E6%AF%94"><span class="toc-text">map 和 submit对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86-%E5%A5%BD%E5%A4%84"><span class="toc-text">线程池原理 好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="toc-text">使用方法示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#web%E6%9C%8D%E5%8A%A1%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8A%A0%E9%80%9F"><span class="toc-text">web服务使用线程池加速</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="toc-text">多进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#web%E6%9C%8D%E5%8A%A1%E4%BD%BF%E7%94%A8%E8%BF%9B%E7%A8%8B%E6%B1%A0"><span class="toc-text">web服务使用进程池</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B-%E5%BC%82%E6%AD%A5IO"><span class="toc-text">协程 异步IO</span></a></li></ol>
            
          </ol>
        </div>
        
          <div class="post-gallery">
            
          </div>
        
        <p>[TOC]</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>python并发编程分三个方面：多线程（threading）、多进程(multiprocessing)、多协程(asynico)</p>
</blockquote>
<p>CPU密集型计算：压缩/解压缩、加密解密、正则表达式搜索</p>
<p>IO密集型计算：文件处理、网络爬虫、读写数据库</p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><ul>
<li><p>进程：</p>
<ul>
<li>优点：可以实现并行，且只有多进程可以实现并行</li>
<li>缺点：占用资源多，可启动数目最少</li>
</ul>
</li>
<li><p>线程：</p>
<ul>
<li>占用资源少，轻量级</li>
<li>python的线程是无法并行的（占用多个cpu)，只能进行并发</li>
<li>切换线程也是有开销的。</li>
<li>适合IO密集型运算、同时运行任务不多(线程可启动数量也是有限制的)</li>
</ul>
</li>
<li><p>协程：</p>
<ul>
<li><p>优点：内存开销最小，可启动数量最多</p>
</li>
<li><p>缺点：支持的库比较少，代码复杂，例如爬虫不支持，所以想用多协程爬取的话，可以用aiohttp，不能用requests</p>
</li>
<li><p>适用于：IO密集型、超多任务运行</p>
</li>
</ul>
</li>
</ul>
<h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><ul>
<li>一个进程中可以启动很多线程</li>
<li>一个线程中可以启动很多协程</li>
</ul>
<h2 id="怎样选择"><a href="#怎样选择" class="headerlink" title="怎样选择"></a>怎样选择</h2><ul>
<li>IO密集型运算优先选择多进程</li>
<li>若满足三点：1、需要超多任务量  2、有现成协程库支持  3、代码复杂度可以接受，则选择协程，否则选择线程</li>
</ul>
<h2 id="python慢的原因"><a href="#python慢的原因" class="headerlink" title="python慢的原因"></a>python慢的原因</h2><p>两个原因</p>
<ul>
<li>是解释型语言，边解释边执行</li>
<li>GIL，无法利用多核CPU</li>
</ul>
<p>GIL是什么，为什么有GIL</p>
<p>   全局解释器锁，是计算机程序设计语言解释器用于==同步==线程的一种机制，它使得任何时刻只有一个线程在运行</p>
<p>   python设计初期为了解决线程并发的问题引入了GIL，但是现在很难去除，本质是一种锁，它的好处在于简化了Python对共享资源的管理</p>
<p>怎样规避GIL带来的限制</p>
<ul>
<li>IO期间线程会释放GIL，实现CPU和IO的并行，因此GIL的存在对于IO密集型计算是友好的，但是对CPU密集型则会拖慢速度</li>
<li>利用multiprocessing，可以利用多核CPU的优势</li>
</ul>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><img src="https://my-pic-1309722427.cos.ap-nanjing.myqcloud.com/img/202307122111161.webp" alt="image-20230712211117603" style="zoom:67%;" />

<h2 id="threading库"><a href="#threading库" class="headerlink" title="threading库"></a>threading库</h2><p><a target="_blank" rel="noopener" href="https://jusene.github.io/2018/02/13/thread/">https://jusene.github.io/2018/02/13/thread/</a></p>
<ul>
<li><strong>threading.active_count()：</strong>返回当前存活的threading.Thread线程对象数量，等同于len(threading.enumerate())。</li>
<li><strong>threading.current_thread()：</strong>返回此函数的调用者控制的threading.Thread线程对象。如果当前调用者控制的线程不是通过threading.Thread创建的，则返回一个功能受限的虚拟线程对象。</li>
<li><strong>threading.get_ident()：</strong>返回当前线程的线程标识符。注意当一个线程退出时，它的线程标识符可能会被之后新创建的线程复用。</li>
<li><strong>threading.enumerate()：</strong>返回当前存活的threading.Thread线程对象列表。</li>
<li><strong>threading.main_thread()：</strong>返回主线程对象，通常情况下，就是程序启动时Python解释器创建的threading._MainThread线程对象。</li>
<li><strong>threading.stack_size([size])：</strong>返回创建线程时使用的堆栈大小。也可以使用可选参数size指定之后创建线程时的堆栈大小，size可以是0或者一个不小于32KiB的正整数。如果参数没有指定，则默认为0。如果系统或者其他原因不支持改变堆栈大小，则会报RuntimeError错误；如果指定的堆栈大小不合法，则会报ValueError，但并不会修改这个堆栈的大小。32KiB是保证能解释器运行的最小堆栈大小，当然这个值会因为系统或者其他原因有限制，比如它要求的值是大于32KiB的某个值，只需根据要求修改即可。</li>
</ul>
<h3 id="线程对象：Thread类"><a href="#线程对象：Thread类" class="headerlink" title="线程对象：Thread类"></a><strong>线程对象：</strong>Thread类</h3><blockquote>
<p><strong>守护线程：</strong>只有所有守护线程都结束，整个Python程序才会退出，但并不是说Python程序会等待守护线程运行完毕，相反，当程序退出时，如果还有守护线程在运行，程序会去强制终结所有守护线程，当守所有护线程都终结后，程序才会真正退出。可以通过修改daemon属性或者初始化线程时指定daemon参数来指定某个线程为守护线程。</p>
<p><strong>非守护线程：</strong>一般创建的线程默认就是非守护线程，包括主线程也是，即在Python程序退出时，如果还有非守护线程在运行，程序会等待直到所有非守护线程都结束后才会退出。</p>
<p><strong>注：</strong>守护线程会在程序关闭时突然关闭（如果守护线程在程序关闭时还在运行），它们占用的资源可能没有被正确释放，比如正在修改文档内容等，需要谨慎使用。</p>
</blockquote>
<p>构造方法：</p>
<p>Thread(group=None,target=None,name=None,arg=(),kwargs=None,*,daemon=None)</p>
<ul>
<li><p>group: 线程组，目前还没有实现，库引用中必须是None</p>
</li>
<li><p>target: 要执行的方法</p>
</li>
<li><p>name: 线程名</p>
</li>
<li><p>args/kwargs: 要传入方法的参数</p>
</li>
<li><p>daemon:</p>
<p>​      默认为false(不适用于IDLE的交互模式或脚本运行模式，因为交互模式下的主线程只有退出PYTHON时才终止)</p>
<ul>
<li>当子线程的daemon属性为false时，主线程结束时会检测子线程是否结束，如果子线程尚未完成，则主线程会等待子线程完成后再退出</li>
<li>当子线程的daemon属性为true时，主线程运行结束时不对子线程进行检查而直接退出，同时子线程随主线程一起结束而不论是否运行完成</li>
</ul>
</li>
</ul>
<p>实例方法：</p>
<ul>
<li><p>isAlive(): 返回线程是否在运行，正在运行指启动后、终止前</p>
</li>
<li><p>getName(): 获取线程名</p>
</li>
<li><p>isDaemon(): 获取是否为后台线程</p>
</li>
<li><p>join(timeout=None): ==阻塞当前上下文环境的线程，直到调用此方法的线程终止或到达指定的timeout，说人话就是会把程序卡在这里，直到这个用了join的线程执行结束才可以执行其他线程,像join(5)就是等待这个线程运行5秒，不加参数就是一直等他运行结束。==</p>
<p>   这里也可以看出join也有一定的==同步==的作用</p>
</li>
<li><p>setDaemon(): 设置为后台线程</p>
</li>
<li><p>setName(name): 设置线程名</p>
</li>
<li><p>start(): 启动线程</p>
</li>
</ul>
<h3 id="锁对象：Lock-amp-递归锁对象：Rlock类"><a href="#锁对象：Lock-amp-递归锁对象：Rlock类" class="headerlink" title="锁对象：Lock &amp; 递归锁对象：Rlock类"></a><strong>锁对象：</strong>Lock &amp; <strong>递归锁对象：</strong>Rlock类</h3><p>由于线程的随机调度：某线程可能在执行n条后，cpu接着执行其他线程。为了多个线程同时操作一个内存中的资源时不产生混乱，我们使用锁。</p>
<p>实例方法：</p>
<ul>
<li>acquire([timeout]): 尝试获得锁定，使线程进入同步阻塞状态。</li>
<li>release(): 释放锁，使用前线程必须已获得锁定，否则抛出异常。</li>
</ul>
<p>Lock属于全局，重复锁定会产生死锁；RLock属于线程，可重复施加锁，需要执行相同次数的锁释放。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading,time</span><br><span class="line">gl_num=<span class="number">0</span></span><br><span class="line">lock=threading.RLock()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">action</span>():</span></span><br><span class="line">    lock.acquire()</span><br><span class="line">    <span class="keyword">global</span> gl_num</span><br><span class="line">    gl_num+=<span class="number">1</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;gl_num&#x27;</span>)</span><br><span class="line">    lock.release()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    t=threading.Thread(target=action)</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>



<h3 id="条件变量对象：Condition类"><a href="#条件变量对象：Condition类" class="headerlink" title="条件变量对象：Condition类"></a><strong>条件变量对象：</strong>Condition类</h3><p>Condition通常与一个锁关联，需要在多个Contidion中共享一个锁时，可以传递一个Lock/RLock实例给构造方法，否则它将自动生产一个RLock实例。<br>可以认为，除了Lock带有的锁定池外，Condition还包含一个等待池，池中的线程处于等待阻塞状态，直到另一个线程调用notify()/notifyAll()通知；得到通知后线程进入锁定池等待锁定。</p>
<p>实例方法:</p>
<ul>
<li>acquire([timeout])/release():调用关联的锁的相应方法</li>
<li>wait([timeout]):调用这个方法将使线程进入Condition的等待池等待通知，并释放锁。使用前线程必须已获得锁定，否则将抛出异常</li>
<li>notify():调用这个方法将从等待池挑选一个线程并通知，收到通知的线程将自动调用acquire()尝试获得锁定，其他线程仍然在等待池中<br>-notifyAll():调用这个方法将通知等待池中所有的线程，这些线程都将进入锁定池尝试获得锁定</li>
</ul>
<h3 id="事件对象：Event类"><a href="#事件对象：Event类" class="headerlink" title="事件对象：Event类"></a><strong>事件对象：</strong>Event类</h3><p>Event是最简单的线程通信机制之一：一个线程通知事件，其他线程等待事件。Event内置了一个为False的标志，当调用set()时设为True,调用clear()时重置为False。wait()将阻塞线程至等待阻塞状态。</p>
<p>实例方法:</p>
<ul>
<li>isSet(): 当内置标志为True时返回True</li>
<li>set(): 将标志设为True,并通知所有处于等待阻塞状态的线程恢复运行状态</li>
<li>clear(): 将标志设为False</li>
<li>wait([timeout]): 如果标志True将立即返回，否则阻塞线程至等待阻塞状态，等待其他线程调用set()</li>
</ul>
<h3 id="定时器对象：timer类"><a href="#定时器对象：timer类" class="headerlink" title="定时器对象：timer类"></a><strong>定时器对象：</strong>timer类</h3><p>Timer(定时器)是Thread的派生类，用于在指定时间后调用一个方法。</p>
<p>构造方法:<br>Timer(interval,function,args=[],kwarg={})</p>
<ul>
<li>interval:指定的时间</li>
<li>function:要执行的方法</li>
<li>args/kwargs:方法的参数</li>
</ul>
<h3 id="local类"><a href="#local类" class="headerlink" title="local类"></a>local类</h3><p>local是一个小写字母开头的类，用于管理thread-local(线程局部)数据。对于同一个local，线程无法访问其他线程设置的属性；线程设置的属性不会被其他线程设置的同名属性替换。</p>
<h2 id="创建多线程"><a href="#创建多线程" class="headerlink" title="创建多线程"></a>创建多线程</h2><p>1、准备一个函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    do_craw(a,b)</span><br></pre></td></tr></table></figure>

<p>2、创建线程</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">t=threading.Thread(target=myfunc,args=(<span class="number">100</span>,<span class="number">200</span>,))</span><br></pre></td></tr></table></figure>

<p>3、启动线程</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.start()</span><br></pre></td></tr></table></figure>

<p>4、等待结束</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.join()</span><br></pre></td></tr></table></figure>





<h2 id="多线程爬虫"><a href="#多线程爬虫" class="headerlink" title="多线程爬虫"></a>多线程爬虫</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>main.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">urls = [</span><br><span class="line">    <span class="string">f&quot;https://test.com/#p<span class="subst">&#123;page&#125;</span>&quot;</span><span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">51</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(urls)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">craw</span>(<span class="params">url</span>):</span></span><br><span class="line">    r = requests.get(url)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(r.text))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">craw(urls[<span class="number">0</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>test.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> main</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">single_thread</span>():</span></span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> main.urls:</span><br><span class="line">        main.craw(url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_thread</span>():</span></span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> main.urls:</span><br><span class="line">        threads.append(</span><br><span class="line">            threading.Thread(target=main.craw, args=(url,))</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.start()</span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.join()</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;for thread in threads: thread.join() 的作用是等待每个线程执行结束。在多线程程序中，线程是并行执行的，如果不等待线程执行完成，程序可能会在某个线程还没有完成运行的情况下就结束了。&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">single_thread()</span><br><span class="line">multi_thread()</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="生产者-消费者-队列"><a href="#生产者-消费者-队列" class="headerlink" title="生产者-消费者-队列"></a>生产者-消费者-队列</h3><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/xmsumi/pythonspider/160105">https://www.kancloud.cn/xmsumi/pythonspider/160105</a></p>
<blockquote>
<p>进程间通信：队列（queue)  管道（pipe）</p>
<p><code>Queue</code>模块实现了多生产者多消费者队列, 尤其适合多线程编程.</p>
<p>列表也可以用作队列，但是它第一个元素移出以后后面的数据都需要向前移动，导致效率很低</p>
</blockquote>
<p><code>Queue</code>类中<code>实现了所有需要的锁原语</code>(这句话非常重要), Queue模块实现了三种类型队列:</p>
<ul>
<li>FIFO(先进先出)队列, 第一加入队列的任务, 被第一个取出</li>
<li>LIFO(后进先出)队列,最后加入队列的任务, 被第一个取出(操作类似与栈, 总是从栈顶取出, 这个队列还不清楚内部的实现)</li>
<li>PriorityQueue(优先级)队列, 保持队列数据有序, 最小值被先取出(在C++中我记得优先级队列是可以自己重写排序规则的, Python不知道可以吗)</li>
</ul>
<p>==三个模块==</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="comment">#类</span></span><br><span class="line">Queue.Queue(maxsize = <span class="number">0</span>)  <span class="comment">#构造一个FIFO队列,maxsize设置队列大小的上界, 如果插入数据时, 达到上界会发生阻塞, 直到队列可以放入数据. 当maxsize小于或者等于0, 表示不限制队列的大小(默认)</span></span><br><span class="line"></span><br><span class="line">Queue.LifoQueue(maxsize = <span class="number">0</span>)  <span class="comment">#构造一LIFO队列,maxsize设置队列大小的上界, 如果插入数据时, 达到上界会发生阻塞, 直到队列可以放入数据. 当maxsize小于或者等于0, 表示不限制队列的大小(默认)</span></span><br><span class="line"></span><br><span class="line">Queue.PriorityQueue(maxsize = <span class="number">0</span>)  <span class="comment">#构造一个优先级队列,,maxsize设置队列大小的上界, 如果插入数据时, 达到上界会发生阻塞, 直到队列可以放入数据. 当maxsize小于或者等于0, 表示不限制队列的大小(默认). 优先级队列中, 最小值被最先取出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#异常</span></span><br><span class="line">Queue.Empty  <span class="comment">#当调用非阻塞的get()获取空队列的元素时, 引发异常</span></span><br><span class="line">Queue.Full  <span class="comment">#当调用非阻塞的put()向满队列中添加元素时, 引发异常</span></span><br></pre></td></tr></table></figure>

<p>Queue</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line">q=queue.Queue()<span class="comment">#创建Queue</span></span><br><span class="line"></span><br><span class="line">Queue.empty()  <span class="comment">#如果队列为空, 返回True(注意队列为空时, 并不能保证调用put()不会阻塞); 队列不空返回False(不空时, 不能保证调用get()不会阻塞)</span></span><br><span class="line">Queue.full()  <span class="comment">#如果队列为满, 返回True(不能保证调用get()不会阻塞), 如果队列不满, 返回False(并不能保证调用put()不会阻塞)</span></span><br><span class="line"></span><br><span class="line">Queue.put(item[, block[, timeout]])  <span class="comment">#向队列中放入元素, 如果可选参数block为True并且timeout参数为None(默认), 为阻塞型put(). 如果timeout是正数, 会阻塞timeout时间并引发Queue.Full异常. 如果block为False为非阻塞put</span></span><br><span class="line">Queue.put_nowait(item)  <span class="comment">#等价于put(itme, False)</span></span><br><span class="line"></span><br><span class="line">Queue.get([block[, timeout]])  <span class="comment">#移除列队元素并将元素返回, block = True为阻塞函数, block = False为非阻塞函数. 可能返回Queue.Empty异常</span></span><br><span class="line">Queue.get_nowait()  <span class="comment">#等价于get(False)</span></span><br><span class="line"></span><br><span class="line">Queue.task_done()  <span class="comment">#在完成一项工作之后，Queue.task_done()函数向任务已经完成的队列发送一个信号</span></span><br><span class="line">Queue.join()  <span class="comment">#实际上意味着等到队列为空，再执行别的操作</span></span><br></pre></td></tr></table></figure>



<h2 id="线程安全-lock"><a href="#线程安全-lock" class="headerlink" title="线程安全 lock"></a>线程安全 lock</h2><blockquote>
<p>线程安全是指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成</p>
<p>由于线程的执行会随时发生切换，造成不可预料的结果，出现线程不安全</p>
</blockquote>
<p>用法1：try-finally模式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">lock = threading.Lock()</span><br><span class="line">lock.acquire()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    do something</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    lock.release()</span><br></pre></td></tr></table></figure>



<p>用法2：with模式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"><span class="keyword">with</span> lock:</span><br><span class="line">    do something</span><br></pre></td></tr></table></figure>



<p>线程不安全的代码：</p>
<p>多线程并发的时候可能出现余额扣到负数的情况</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, balance</span>):</span></span><br><span class="line">        self.balance = balance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw</span>(<span class="params">acc, amount</span>):</span></span><br><span class="line">    <span class="keyword">if</span> acc.balance &gt;= amount:</span><br><span class="line">        <span class="built_in">print</span>(threading.current_thread().name, <span class="string">&quot;取钱成功&quot;</span>)</span><br><span class="line">        acc.balance -= amount</span><br><span class="line">        <span class="built_in">print</span>(threading.current_thread().name, <span class="string">&quot;余额&quot;</span>, acc.balance)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(threading.current_thread().name, <span class="string">&quot;取钱失败，余额不足&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    account = Account(<span class="number">1000</span>)</span><br><span class="line">    ta = threading.Thread(name=<span class="string">&quot;ta&quot;</span>, target=draw, args=(account, <span class="number">800</span>))</span><br><span class="line">    tb = threading.Thread(name=<span class="string">&quot;tb&quot;</span>, target=draw, args=(account, <span class="number">800</span>))</span><br><span class="line">    tc = threading.Thread(name=<span class="string">&quot;tc&quot;</span>, target=draw, args=(account, <span class="number">800</span>))</span><br><span class="line">    td = threading.Thread(name=<span class="string">&quot;td&quot;</span>, target=draw, args=(account, <span class="number">800</span>))</span><br><span class="line">    te = threading.Thread(name=<span class="string">&quot;te&quot;</span>, target=draw, args=(account, <span class="number">800</span>))</span><br><span class="line">    ta.start()</span><br><span class="line">    tb.start()</span><br><span class="line">    tc.start()</span><br><span class="line">    td.start()</span><br><span class="line">    te.start()</span><br></pre></td></tr></table></figure>

<p><img src="https://my-pic-1309722427.cos.ap-nanjing.myqcloud.com/img/202307121547576.webp" alt="image-20230712154715256"></p>
<p>而在draw函数加一个sleep，则100%触发，因为sleep会阻塞线程且发生线程切换</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw</span>(<span class="params">acc, amount</span>):</span></span><br><span class="line">    <span class="keyword">if</span> acc.balance &gt;= amount:</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        <span class="built_in">print</span>(threading.current_thread().name, <span class="string">&quot;取钱成功&quot;</span>)</span><br><span class="line">        acc.balance -= amount</span><br><span class="line">        <span class="built_in">print</span>(threading.current_thread().name, <span class="string">&quot;余额&quot;</span>, acc.balance)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(threading.current_thread().name, <span class="string">&quot;取钱失败，余额不足&quot;</span>)</span><br></pre></td></tr></table></figure>



<p>引进lock就安全了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, balance</span>):</span></span><br><span class="line">        self.balance = balance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw</span>(<span class="params">acc, amount</span>):</span></span><br><span class="line">    <span class="keyword">with</span> lock:</span><br><span class="line">        <span class="keyword">if</span> acc.balance &gt;= amount:</span><br><span class="line">            time.sleep(<span class="number">0.1</span>)</span><br><span class="line">            <span class="built_in">print</span>(threading.current_thread().name, <span class="string">&quot;取钱成功&quot;</span>)</span><br><span class="line">            acc.balance -= amount</span><br><span class="line">            <span class="built_in">print</span>(threading.current_thread().name, <span class="string">&quot;余额&quot;</span>, acc.balance)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(threading.current_thread().name, <span class="string">&quot;取钱失败，余额不足&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    account = Account(<span class="number">1000</span>)</span><br><span class="line">    ta = threading.Thread(name=<span class="string">&quot;ta&quot;</span>, target=draw, args=(account, <span class="number">800</span>))</span><br><span class="line">    tb = threading.Thread(name=<span class="string">&quot;tb&quot;</span>, target=draw, args=(account, <span class="number">800</span>))</span><br><span class="line">    tc = threading.Thread(name=<span class="string">&quot;tc&quot;</span>, target=draw, args=(account, <span class="number">800</span>))</span><br><span class="line">    td = threading.Thread(name=<span class="string">&quot;td&quot;</span>, target=draw, args=(account, <span class="number">800</span>))</span><br><span class="line">    te = threading.Thread(name=<span class="string">&quot;te&quot;</span>, target=draw, args=(account, <span class="number">800</span>))</span><br><span class="line">    ta.start()</span><br><span class="line">    tb.start()</span><br><span class="line">    tc.start()</span><br><span class="line">    td.start()</span><br><span class="line">    te.start()</span><br></pre></td></tr></table></figure>



<h2 id="线程池-threadpoolexecutor"><a href="#线程池-threadpoolexecutor" class="headerlink" title="线程池 threadpoolexecutor"></a>线程池 threadpoolexecutor</h2><blockquote>
<p>线程池的基类是 concurrent.futures 模块中的 Executor，Executor 提供了两个子类，即 ThreadPoolExecutor 和 ProcessPoolExecutor，其中 ThreadPoolExecutor 用于创建线程池，而 ProcessPoolExecutor 用于创建进程池。</p>
<p>线程池在系统启动时即创建大量空闲的线程，程序只要将一个函数提交给线程池，线程池就会启动一个空闲的线程来执行它。当该函数执行结束后，该线程并不会死亡，而是再次返回到线程池中变成空闲状态，等待执行下一个函数。</p>
<p>如果使用线程池/进程池来管理并发编程，那么只要将相应的 task 函数提交给线程池/进程池，剩下的事情就由线程池/进程池来搞定。</p>
</blockquote>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>==Exectuor 提供了如下常用方法==：</p>
<ul>
<li>submit(fn, *args, *<em>kwargs)：将 fn 函数提交给线程池。</em>args 代表传给 fn 函数的参数，*kwargs 代表以关键字参数的形式为 fn 函数传入参数。</li>
<li>map(func, *iterables, timeout=None, chunksize=1)：该函数类似于全局函数 map(func, *iterables)，只是该函数将会启动多个线程，以异步方式立即对 iterables 执行 map 处理。</li>
<li>shutdown(wait=True)：关闭线程池。</li>
</ul>
<p>==Future 提供了如下方法==：(也就是submit打头，<code>ThreadPoolExecutor.submit()</code>方法将返回一个<code>future</code>对象)</p>
<ul>
<li><p>cancel()：取消该 Future 代表的线程任务。如果该任务正在执行，不可取消，则该方法返回 False；否则，程序会取消该任务，并返回 True。</p>
</li>
<li><p>cancelled()：返回 Future 代表的线程任务是否被成功取消。</p>
</li>
<li><p>running()：如果该 Future 代表的线程任务正在执行、不可被取消，该方法返回 True。</p>
</li>
<li><p>done()：如果该 Funture 代表的线程任务被成功取消或执行完成，则该方法返回 True。</p>
</li>
<li><p>==result==(timeout=None)：获取该 Future 代表的线程任务最后返回的结果。如果 Future 代表的线程任务还未完成，该方法将会阻塞当前线程，其中 timeout 参数指定最多阻塞多少秒。</p>
</li>
<li><p>exception(timeout=None)：获取该 Future 代表的线程任务所引发的异常。如果该任务成功完成，没有异常，则该方法返回 None。</p>
</li>
<li><p>add_done_callback(fn)：为该 Future 代表的线程任务注册一个“回调函数”，当该任务成功完成时，程序会自动触发该 fn 函数。</p>
<p><code>as_completed()</code><strong>方法用于将线程池返回的future对象按照线程完成的顺序排列</strong>，不加也可以，不加则返回的顺序为<strong>按线程创建顺序返回</strong>。</p>
<p><code>with</code>语句将自动关闭线程池，也就是自动执行shutdown方法。</p>
<blockquote>
<p>在用完一个线程池后，应该调用该线程池的 <code>shutdown()</code> 方法，该方法将启动线程池的关闭序列。调用 <code>shutdown()</code> 方法后的线程池不再接收新任务，但会将以前所有的已提交任务执行完成。当线程池中的所有任务都执行完成后，该线程池中的所有线程都会死亡。</p>
</blockquote>
</li>
</ul>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>调用 ThreadPoolExecutor 类的构造器创建一个线程池。</li>
<li>定义一个普通函数作为线程任务。</li>
<li>调用 ThreadPoolExecutor 对象的 submit() 方法来提交线程任务。</li>
<li>当不想提交任何任务时，调用 ThreadPoolExecutor 对象的 shutdown() 方法来关闭线程池。</li>
</ol>
<h3 id="map-和-submit对比"><a href="#map-和-submit对比" class="headerlink" title="map 和 submit对比"></a>map 和 submit对比</h3><ul>
<li>易用性</li>
</ul>
<p><code>map()</code>方法比较容易使用，它的参数是一个==可迭代对象==（如列表）和一个函数，函数将被应用于可迭代对象中的每个元素，然后返回一个生成器对象，生成器对象可以逐个访问结果。<code>submit()</code>方法的使用要稍微复杂一点，需要单独执行每个线程执行任务，并使用<code>Future</code>对象来管理和访问结果。</p>
<ul>
<li>控制方法</li>
</ul>
<p>使用<code>map()</code>方法时，线程的数量是由线程池中的工作线程数量决定的。如果你想要更细粒度的控制，可以使用<code>submit()</code>方法，使用<code>max_workers</code>参数来指定线程池的大小，使用<code>shutdown()</code>方法来关闭线程池。</p>
<ul>
<li>访问方法</li>
</ul>
<p>使用<code>map()</code>方法时，无法访问单独的线程和它们的结果，只能访问生成器对象中的一个接一个的结果。使用<code>submit()</code>方法时，可以访问每个线程的状态，可以使用<code>Future</code>对象的方法来检查和访问线程结果。例如，可以使用<code>done()</code>方法来检查线程是否完成，使用<code>result()</code>方法来访问线程的返回值，使用<code>exception()</code>方法来访问线程的异常。</p>
<p>总的来说，<code>map()</code>方法更简单易用，并且适用于处理一组数据集。<code>submit()</code>方法更加灵活，允许你更好地控制线程池，并且可以访问单个线程状态和结果。</p>
<h3 id="线程池原理-好处"><a href="#线程池原理-好处" class="headerlink" title="线程池原理 好处"></a>线程池原理 好处</h3><p>  新建线程需要分配资源、终止线程需要回收资源，如果可以重用线程，则可以减去新建/终止的开销</p>
<img src="https://my-pic-1309722427.cos.ap-nanjing.myqcloud.com/img/202307122114180.webp" alt="image-20230712211421887" style="zoom:50%;" />



<ul>
<li>提升性能：减去了大量新建、终止线程的开销，重用了线程资源</li>
<li>适用场景：适合处理突发性大量请求或需要大量线程完成任务、但实际任务处理时间较短</li>
<li>防御功能：能有效避免系统因为创建线程过多，从而导致系统负荷过大相应变慢等问题</li>
<li>代码优势：使用线程池的语法比自己新建线程执行线程更加简洁</li>
</ul>
<h3 id="使用方法示例"><a href="#使用方法示例" class="headerlink" title="使用方法示例"></a>使用方法示例</h3><blockquote>
<p>ThreadPoolExecutor()构造参数：</p>
<ul>
<li><code>max_workers</code> 设置线程池中最多能同时运行的线程数目。</li>
<li><code>thread_name_prefix</code> 线程名字前缀</li>
<li><code>initializer</code> 在每个工作线程启动之前，执行初始化函数，如果没有指定，默认为None。</li>
<li><code>initargs</code> 传递给初始化函数的参数元组，如果没有指定，默认为空元组()。</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor,as_completed</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用法1：map函数，注意map的结果和入参顺序是对应的</span></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor() <span class="keyword">as</span> pool:</span><br><span class="line">    results = pool.<span class="built_in">map</span>(func_name,args)</span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 用法2：future模式，更强大，注意如果用as_completed顺序是线程执行完成的顺序</span></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor() <span class="keyword">as</span> pool:</span><br><span class="line">    futures = [pool.submit(func_name,args) <span class="keyword">for</span> args <span class="keyword">in</span> urls]</span><br><span class="line">    <span class="comment"># 2.1用法</span></span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> futures:</span><br><span class="line">        <span class="built_in">print</span>(future.result())</span><br><span class="line">    <span class="comment"># 2.2用法</span></span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> as_completed(futures):</span><br><span class="line">        <span class="built_in">print</span>(future.result())</span><br></pre></td></tr></table></figure>



<p>代码示例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数times用来模拟网络请求的时间</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html</span>(<span class="params">times</span>):</span></span><br><span class="line">    time.sleep(times)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;get page &#123;&#125;s finished&quot;</span>.<span class="built_in">format</span>(times))</span><br><span class="line">    <span class="keyword">return</span> times</span><br><span class="line"></span><br><span class="line">executor = ThreadPoolExecutor(max_workers=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 通过submit函数提交执行的函数到线程池中，submit函数立即返回，不阻塞</span></span><br><span class="line">task1 = executor.submit(get_html, (<span class="number">3</span>))</span><br><span class="line">task2 = executor.submit(get_html, (<span class="number">2</span>))</span><br><span class="line"><span class="comment"># done方法用于判定某个任务是否完成</span></span><br><span class="line"><span class="built_in">print</span>(task1.done())</span><br><span class="line"><span class="comment"># cancel方法用于取消某个任务,该任务没有放入线程池中才能取消成功</span></span><br><span class="line"><span class="built_in">print</span>(task2.cancel())</span><br><span class="line">time.sleep(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(task1.done())</span><br><span class="line"><span class="comment"># result方法可以获取task的执行结果</span></span><br><span class="line"><span class="built_in">print</span>(task1.result())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line"><span class="comment"># False  # 表明task1未执行完成</span></span><br><span class="line"><span class="comment"># False  # 表明task2取消失败，因为已经放入了线程池中</span></span><br><span class="line"><span class="comment"># get page 2s finished</span></span><br><span class="line"><span class="comment"># get page 3s finished</span></span><br><span class="line"><span class="comment"># True  # 由于在get page 3s finished之后才打印，所以此时task1必然完成了</span></span><br><span class="line"><span class="comment"># 3     # 得到task1的任务返回值</span></span><br></pre></td></tr></table></figure>



<h3 id="web服务使用线程池加速"><a href="#web服务使用线程池加速" class="headerlink" title="web服务使用线程池加速"></a>web服务使用线程池加速</h3><p>1)threaded : 多线程支持，默认为False，即不开启多线程;</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.run(threaded=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>2)processes：进程数量，默认为1.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.run(processes=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>ps：多进程或多线程只能选择一个，不能同时开启</p>
<p><strong>使用示例：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.run(host=myaddr,port=myport,debug=<span class="literal">False</span>,threaded=<span class="literal">True</span>) <span class="comment">### threaded开启以后 不需要等队列 threaded=True</span></span><br><span class="line">  <span class="comment">#或者</span></span><br><span class="line">  <span class="comment">#app.run(host=myaddr,port=myport,debug=False,processes=3) ### processes=N 进程数量，默认为1个</span></span><br></pre></td></tr></table></figure>



<p>flask加速</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="comment"># DOCS https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor</span></span><br><span class="line">executor = ThreadPoolExecutor(<span class="number">2</span>)</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/jobs&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_jobs</span>():</span></span><br><span class="line"> <span class="comment"># 通过submit函数提交执行的函数到线程池中，submit函数立即返回，不阻塞</span></span><br><span class="line"> executor.submit(long_task, <span class="string">&#x27;hello&#x27;</span>, <span class="number">123</span>)</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;long task running.&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_task</span>(<span class="params">arg1, arg2</span>):</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;args: %s %s!&quot;</span> % (arg1, arg2))</span><br><span class="line"> sleep(<span class="number">5</span>)</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;Task is done!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"> app.run()</span><br></pre></td></tr></table></figure>



<h1 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h1><p><strong>有了多线程为什么还要有多进程？</strong></p>
<p>如果是CPU密集型计算，多线程反而会降低速度（多线程只占用一个处理机，它能实现CPU运算和IO同时运行，也就是一个线程进入IO后能直接转入下一个线程的执行，但是也因为它只占用一个处理机，同一时刻只能有一个线程进行CPU运算）</p>
<p><strong>多进程知识梳理</strong></p>
<p><img src="https://my-pic-1309722427.cos.ap-nanjing.myqcloud.com/img/202307122309457.webp" alt="image-20230712230951890"></p>
<p><strong>对于CPU密集型计算的运行时间对比</strong></p>
<img src="https://my-pic-1309722427.cos.ap-nanjing.myqcloud.com/img/202307122314519.webp" alt="image-20230712231401133" style="zoom: 50%;" />



<h2 id="web服务使用进程池"><a href="#web服务使用进程池" class="headerlink" title="web服务使用进程池"></a>web服务使用进程池</h2><p>和线程池类似，注意的地方就是flask使用进程池要傲娇一些</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    process_pool = ProcessPoolExecutor()</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>



<h1 id="协程-异步IO"><a href="#协程-异步IO" class="headerlink" title="协程 异步IO"></a>协程 异步IO</h1><p>单线程爬虫的执行路径</p>
<p><img src="https://my-pic-1309722427.cos.ap-nanjing.myqcloud.com/img/202307122338145.webp" alt="image-20230712233816775"></p>
<p>协程：在单线程内实现并发</p>
<p><img src="https://my-pic-1309722427.cos.ap-nanjing.myqcloud.com/img/202307122339446.webp" alt="image-20230712233955139"></p>
<p>异步IO库：asyncio</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取事件循环</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="comment">#定义协程</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">myfunc</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">await</span> get_url(url)</span><br><span class="line"><span class="comment">#创建task列表</span></span><br><span class="line">tasks = [loop.create_task(myfunc(url)) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line"><span class="comment">#执行爬虫事件列表</span></span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br></pre></td></tr></table></figure>

<p>==注意:==</p>
<p>要用在异步IO编程中,依赖的库必须支持异步IO特性</p>
<p>爬虫引用中:requests 不支持异步需要用aiohttp</p>

      </div>
    </div>
  </article>
  <div class="post__foot">
    
    <div class="post-nav">
  
    <a class="post-nav-item-left" href="/2023/07/16/7.29/403bypass/">
      <div class="text-align">
        <svg t="1670570876164"
             class="icon"
             viewBox="0 0 1024 1024"
             width="16"
             height="16">
          <path d="M384 512L731.733333 202.666667c17.066667-14.933333 19.2-42.666667 4.266667-59.733334-14.933333-17.066667-42.666667-19.2-59.733333-4.266666l-384 341.333333c-10.666667 8.533333-14.933333 19.2-14.933334 32s4.266667 23.466667 14.933334 32l384 341.333333c8.533333 6.4 19.2 10.666667 27.733333 10.666667 12.8 0 23.466667-4.266667 32-14.933333 14.933333-17.066667 14.933333-44.8-4.266667-59.733334L384 512z" p-id="14596"/>
        </svg>
        <span class="text-small">上一篇</span>
      </div>
      <div>403bypass</div>
    </a>
  
  <div class="vhr"></div>
  
    <a class="post-nav-item-right" href="/2023/07/12/7.29/php-socket/">
      <div class="text-align">
        <span class="text-small">下一篇</span>
        <svg t="1670570876164"
             class="icon"
             viewBox="0 0 1024 1024"
             transform="scale(-1,-1)"
             width="16"
             height="16">
          <path d="M384 512L731.733333 202.666667c17.066667-14.933333 19.2-42.666667 4.266667-59.733334-14.933333-17.066667-42.666667-19.2-59.733333-4.266666l-384 341.333333c-10.666667 8.533333-14.933333 19.2-14.933334 32s4.266667 23.466667 14.933334 32l384 341.333333c8.533333 6.4 19.2 10.666667 27.733333 10.666667 12.8 0 23.466667-4.266667 32-14.933333 14.933333-17.066667 14.933333-44.8-4.266667-59.733334L384 512z" p-id="14596"/>
        </svg>
      </div>
      php socket编程
    </a>
  
</div>

    
    
  </div>

    </div>
    <div class="foot">
      <div class="foot-inner">
        <div class="foot__head">
          
            <div class="foot-line">
              <div class="matts">安</div><div class="matts">得</div><div class="matts">倚</div><div class="matts">天</div><div class="matts">剑</div>
            </div>
          
            <div class="foot-line">
              <div class="matts">跨</div><div class="matts">海</div><div class="matts">斩</div><div class="matts">长</div><div class="matts">鲸</div>
            </div>
          
        </div>
        <div class="foot__body">
          
            <div class="foot-item">
              <div class="foot-item__head">朋友</div>
              <div class="foot-item__body">
                
                  <div class="text">
                    <img alt="link"
                         height="20px"
                         width="20px"
                         src="/images/icon/icon-link.svg"/>
                    <a class="foot-link" target="_blank" rel="noopener" href="https://blog.huamang.xyz/">huamang</a>
                  </div>
                
                  <div class="text">
                    <img alt="link"
                         height="20px"
                         width="20px"
                         src="/images/icon/icon-link.svg"/>
                    <a class="foot-link" target="_blank" rel="noopener" href="https://www.cnblogs.com/Aurora-M/">Aurora</a>
                  </div>
                
                <div class="text">
                  <img alt="link"
                       height="20px"
                       width="20px"
                       src="/images/icon/icon-link+.svg"/>
                  <a class="foot-link"
                     href="mailto:735587142@qq.com?subject=%E7%94%B3%E8%AF%B7%20Hozen.site%20%E7%9A%84%E5%8F%8B%E9%93%BE%E4%BD%8D%E7%BD%AE">
                  申请友链</a>
                </div>
              </div>
            </div>
          
          
            <div class="foot-item">
              <div class="foot-item__head">账号</div>
              <div class="foot-item__body">
                
                  <div class="text">
                    <img alt="link" height="20px" width="20px" src="/images/logo-github.svg"/>
                    <a class="foot-link" target="_blank" rel="noopener" href="https://github.com/MUNG29">github</a>
                  </div>
                
                  <div class="text">
                    <img alt="link" height="20px" width="20px" src="/images/QQ.png"/>
                    <a class="foot-link" href="">735587142</a>
                  </div>
                
              </div>
            </div>
          
          <div class="foot-item">
            <div class="foot-item__head">联系</div>
            <div class="foot-item__body">
              <div class="text">
                <img alt="link"
                     height="20px"
                     width="20px"
                     src="/images/icon/icon-email.svg"/>
                <a class="foot-link" href="mailto:735587142@qq.com">735587142@qq.com</a>
              </div>
            </div>
          </div>
        </div>
        <div class="copyright">
          <a href="https://MUNG29.github.io">东隅's blog</a> &nbsp;|&nbsp;由&nbsp;<a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>&nbsp;及&nbsp;
          <svg width="20" height="20" viewBox="0 0 725 725">
            <path fill-rule="evenodd" fill="rgb(221, 221, 221)"
            d="M145.870,236.632 L396.955,103.578 L431.292,419.44 L156.600,522.53 L145.870,236.632 Z" />
            <path fill-rule="evenodd" fill="rgb(159, 159, 159)"
            d="M396.955,103.578 L564.345,234.486 L611.558,513.469 L431.292,419.44 L396.955,103.578 Z" />
            <path fill-rule="evenodd" fill="rgb(0, 0, 0)"
            d="M431.292,419.44 L611.558,513.469 L358.327,595.18 L156.600,522.53 L431.292,419.44 Z" />
          </svg>
          <a target="_blank" rel="noopener" href="https://github.com/hooozen/hexo-theme-tranquility">致远</a>&nbsp;驱动
        </div>
      </div>
    </div>
    
      <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    
  
  
    <script type="text/javascript" src=/js/toc.js></script>
  

  </body>
</html>
